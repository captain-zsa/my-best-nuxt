# Общие для всех языков моменты

## all.1. Форматирование

all.1.1. Отступ 2 пробела для языков, в которых блоки формируются не символами, а отступами (Pug, Stylus, Haml, Slim и т.д.), отступ 4 пробела во всех остальных языках. Использование символа табуляции недопустимо. Исключения:

- YAML, который попадает под CS бэкендеров и отступы в котором также должны быть в 4 пробела. Если конечно мы будем его когда-нибудь использовать
- Makefile, который поддерживает только отступы табуляцией (опять же классная тема, если когда-нибудь будем делать)

```
editorconfig: indent_size = 4, indent_style = space
jshint: indent: 4
```

all.1.2. Переводы строк - только LF (Unix).

```
editorconfig: end_of_line = lf
```

all.1.3. В конце строк, а также на пустых строках пробелов нет. Исключения: markdown и yaml, в котором также может содержаться markdown разметка. Причина исключения - в markdown два концевых пробела рендерятся в `<br />`

```
editorconfig: trim_trailing_whitespace = true
```

all.1.4. В конце файла обязательна пустая строка. Причина - корректные диффы в git.

```
editorconfig: insert_final_newline = true
```

all.1.5. Максимальная длина строки 120, рекомендуемая 80. Превышение допустимо, например, при размещении в комментарии длинной ссылки.

all.1.6. При разбиении длинных строк на несколько операторы переносятся на новую строку:

```js
if (firstVeryLongCondition
    && secondVeryLongCondition
) {
    debugger;
}
```

all.1.7. При разбиении длинных строк на несколько chained вызовы переносятся на новую строку вместе с точкой:

```js
object
    .method1()
    .method2();
```

all.1.8. Пробелы вокруг бинарных и тернарных операторов обязательны. Включая, но не ограничиваясь списком `=`, `==`, `!=`, `===`, `!==`, `=>`, `<`, `>`, `&&`, `||`

```js
let a = b * c + d * e;
let f = g > h ? i : j;
```

all.1.9. Перед унарными постфиксными операторами (`i++`, `i--`), а также после унарных префиксных (`!!i`, `!i`, `++i`, `--i`, `-i`) пробел не ставится.

all.1.10. Пробелы в индексах: вокруг простых или отсутствующих не ставятся (`i[1]`, `i['key']`, `let i = []`), вокруг сложных ставятся (`i[ n + 1 ]`, `i[ somefunc(x) ]`).

all.1.11. Пробелы в фигурных скобках не ставятся.

all.1.12. Пробелы в вызовах не ставятся.

all.1.13. После запятых и точек с запятой (если они не расположены в конце строки) ставятся пробелы. Перед запятой и точкой с запятой пробелы не ставятся.

all.1.14. Если в строке не требуется интерполяция переменных, она должна быть в одинарных кавычках.

all.1.15. В многострочных массивах и объектах запятую следует ставить после каждого элемента, включая последний. Даже в JavaScript, в котором лишние запятые уберутся при транспиляции и минификации.

all.1.16. Форматирование "comma first", когда в списках переменных, а также между элементами массивов и объектов запятая ставится в начале строки, - недопустимо.

all.1.17. Если объект состоит из однострочных пар ключ-значение, его следует выравнивать по вертикали: разделитель подгоняется пробелами вправо в вертикальную линию и имеет с обеих сторон хотя бы по одному пробелу:

```js
let a = {
    firstKey    : 1,
    t           : 2,
    veryLongKey : 3,
}
```

all.1.18. Блок кода начинается на той же строке, что и оператор (стиль K&R):

```js
if (condition) {
}
```

all.1.19. Блок кода закрывывается с тем же отступом, что и оператор, открывший блок. Никакого другого кода в строке завершения блока быть не должно. Если после блока - код, а не закрытие другого блока, то между ними требуется пустая строка.

```js
if (condition) {
    if (anotherCondition) {
    }

    'some code';

    if (lastCondition) {
    }
}
```

all.1.20. Требование по закрытию блока на отдельной строке также означает, что операторы `else`, `elsif` и подобные всегда пишутся с новой строки:

```js
if (condition) {
}

else {
}
```

all.1.21. При использовании автоформаттеров переформатированные исходники стоит коммитить отдельно.

---

## all.2. Именование

all.2.1. Имя переменной должно быть словом или фразой на английском языке. Из имени сразу должно быть понятно назначение.

all.2.2. Недопустимо использовать однобуквенные переменные, кроме как для счётчика в цикле `for` (лучше этот цикл не использовать)

all.2.3. Переменные всегда именуются с маленькой буквы.

all.2.4. Классы (объекты, содержащие конструктор) и неймспейсы всегда именуются с большой буквы (PascalCase).

all.2.5. Константы (не es2015 `const`, а вынесенные наверх магические значения) всегда именуются в верхнем регистре и с подчёркиванием в качестве разделителя `CAPS_LOCK`

all.2.6. Имена массивов – во множественном числе: `items`. Имена скаляров - в единственном числе: `item`.

all.2.7. Приватные переменные именуются, начиная со знача подчёркивания: `_imPrivate`.

all.2.8. Если переменная - boolean, она должна начинаться с префиксов `is` / `are` / `has` / `have`: `isSetupComplete`.

all.2.9. Функция должна выполнять одну задачу. Если их несколько - значит нужно несколько функций.

all.2.10. Имена функций и методов должны содержать глагол и по возможности начинаться с него: `function refillBalance(){}`.

all.2.11. Используйте устоявшиеся пары антонимов в именах функций. В книге Стива Макконелла «Совершенный код» приводятся устоявшиеся пары антонимов, рекомендуемые для использования в именах функций/методов, а именно:

```
add / remove
begin / end
create / destroy
first / last
increment / decrement
insert / delete
lock / unlock
min / max
next / prev
old / new
open / close
show / hide
source / target
start / stop
up / down
```

Использование «несогласованных» пар глаголов вроде `add / delete` или `insert / destroy` вводит в заблуждение и усложняет анализ кода.

---

## all.3. Комментарии

all.3.1. Между символами начала комментария и текстом - один пробел:

```js
// Комментарий
```

all.3.2. Пустая строка перед строкой комментария.

all.3.3. Комментарий внутри блока по отступам соответствует отступу кода в этом блоке:

```js

// Комментарий верхнего уровня
if (something) {

    // Комментарий в блоке
    debugger;
}
```

all.3.4. Не стоит комментировать каждую строку, код должен быть понятен сам по себе. Комментировать нужно в первую очередь функции, инклуды и подобные блоки кода - краткое описание, тип и значение аргументов. В языках, где есть стандарты документирования - используются они.

---

## all.4. Прочее

all.4.1. Не следует увлекаться логикой в шаблонах. Чем более готовые к выводу данные в них приходят - тем лучше.

all.4.2. Нельзя использовать в шаблонах и скриптах склеивание css-классов, а также путей к файлам из кусков (`blockname + '_some_mod'`)  - иначе потом не найти

all.4.3. Избегайте множественных вложенных вызовов. Промежуточные результаты можно сложить в переменную:

```js
// Плохо
let url = encodeURIComponent(MyUtil.trim(MyClass.getSomeString(MyData.replace('a', 'b'))));

// Хорошо
let url;
let urlCleaned;
let urlPrepared;
let urlTrimmed;

urlCleaned  = MyData.replace('a', 'b');
urlPrepared = MyClass.getSomeString(urlCleaned);
urlTrimmed  = MyUtil.trim(urlPrepared);
url         = encodeURIComponent(urlTrimmed);
```

all.4.4. Не более 3-4 аргументов у функции. Если нужно больше - лучше передать объект.

all.4.5. Интерполяция лучше конкатенации:

```javascript
// Хорошо
`this is an ${adjective} string`;

// Плохо
'this is an ' + adjective + ' string';
```
